<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on dtaskai&#39;s blog</title>
    <link>https://dtaskai.me/post/</link>
    <description>Recent content in Posts on dtaskai&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Copyright 2022, Dominik TÃ¡skai</copyright>
    <lastBuildDate>Sun, 12 Jun 2022 10:25:39 +0200</lastBuildDate><atom:link href="https://dtaskai.me/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>mTLS enforcement with OPA Gatekeeper</title>
      <link>https://dtaskai.me/post/mtls-enforcement-with-gatekeeper/</link>
      <pubDate>Sun, 12 Jun 2022 10:25:39 +0200</pubDate>
      
      <guid>https://dtaskai.me/post/mtls-enforcement-with-gatekeeper/</guid>
      <description>Due to internal policies it might be mandatory to only allow mTLS-protected traffic inside your cluster between your services. To break this down into steps that can be easily implemented we need:
 a way to enable mTLS in the cluster, for this we are going to use Linkerd an Ingress Controller, since Linkerd does not provide one by default, the choice here is going to be the NGINX Ingress Controller an approach that lets us ensure that every new service (be it a Deployment, Statefulset, DaemonSet or ReplicaSet), gets automatically meshed and thus enables mTLS traffic to and from the aforementioned service, the final piece to our puzzle is going to be one of OPA Gatekeeper&amp;rsquo;s new mutating CRDs.</description>
    </item>
    
    <item>
      <title>Cancel a launched goroutine</title>
      <link>https://dtaskai.me/post/go-cancel-a-launched-goroutine/</link>
      <pubDate>Mon, 30 May 2022 15:29:21 +0200</pubDate>
      
      <guid>https://dtaskai.me/post/go-cancel-a-launched-goroutine/</guid>
      <description>One of the more challenging tasks in the past few months was for me was to find a way to implement the following feature:
After a set amount of seconds (provided in the form of an environment variable) launch a goroutine which sends control data to another service with a way to cancel the whole process in case of an external event. If you come from perhaps a Java background then this task seems pretty trivial, you &amp;ldquo;just&amp;rdquo; have to call the interrupt() function on your thread, but with goroutines this is not an option.</description>
    </item>
    
    <item>
      <title>Timezone pitfall in Go and Docker</title>
      <link>https://dtaskai.me/post/go-timezone-docker/</link>
      <pubDate>Mon, 23 May 2022 15:08:33 +0200</pubDate>
      
      <guid>https://dtaskai.me/post/go-timezone-docker/</guid>
      <description>While working on a project I received a bug report that there is a 1 hour difference between dates at one part of my service and after an hour of trying to reproduce to issue, we came to the conclusion that the reason why it was so hard to track down was that our GKE cluster operates in the UTC timezone, while my local environment (and even our production cluster) is in the Europe/Budapest timezone.</description>
    </item>
    
  </channel>
</rss>
